---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by xudong12.
--- DateTime: 2020/7/6 4:54 PM
---



local function get_respid()
    local time=os.time()
    math.randomseed(time)
    local rand=math.random(100000,999999)
    return tostring(time)..tostring(rand)
end


local IDX = {}
local utils = require('utils')
function IDX:new(o)
    o = o or {}
    setmetatable(o, self)
    self.__index = self
    return o
end
local PRODUCT_MODULE_CLASSES = {}
local PRODUCT_MODNAMES = {sfst='sfst_module'}
for product_name,module_name in pairs(PRODUCT_MODNAMES) do
    PRODUCT_MODULE_CLASSES[product_name] = require(string.format("ad_idx.modules.%s", module_name))
end

-- 初始化
-- 所有可能用到的变量，在此声明
-- param req_body为uve请求体body字符串
-- param uve 解析后的uve请求体结构
function IDX:init(req_body, uve)
    self.req_body = req_body
    self.post_data = {} -- 请求广告引擎需要的POST数据
    -- 本次流量要出哪些产品线的广告 {"A", "B",...}
    self.strategy_products = uve.strategy_products -- 业务策略中指出的且IDX已支持的产品线, 数组
    self.products = {} -- 经过流量控制等过滤后，最终决定访问哪些产品线, 数组
    self.module_dict = {} -- 对应各个引擎模块 {"product":module, ...}
    self.capture_requests = {} -- capture的请求串，数组
    self.responses = {} -- 并行请求各业务线的返回结果，数组
    self.winners = {} -- 竞价胜出的广告, 数组
end

-- 检查Sfst的请求是否有效
-- @return 有效返回ture，否则返回false
function IDX:parse_sfst_request()
    return true
end

-- 对上游请求进行初始化
function IDX:init_request()
    -- 按照广告位降低重新排序imp
    table.sort(self.uve.imp, function(a, b)
        return a.position < b.position
    end)

    -- 标识本次请求是否包含广告位1
    for _,imp in ipairs(self.uve.imp) do
        if imp.position == 1 then
            self.req_has_pos_1 = true
        end
    end

    -- 获取竞价广告位首位的position取值
    self:get_req_first_bid_pos()

    -- 获取竞价广告位首位的position取值
    self:get_req_last_bid_pos()

    -- 为每个position生成impid
    for i,v in ipairs(self.uve.imp) do
        v.impid = string.format("%s%02d", self.uve.idx_id, v.position)
        table.insert(self.impids, v.impid)
        -- 视频后推荐流次首位不进行尾部填充, 在此处删除
        if self.uve.service ~= D.SERVICES.VIDEOFEED or i ~= 2 then
            table.insert(self.miss_impids, {impid = v.impid, position = v.position})
        end
        -- 建立impid和请求体中imp[i]结构关联关系
        self.imp_dict[v.impid] = v
    end

    -- 主信息流竞价位首位WAX-PDB按比例优先规则
    if self.uve.service == D.SERVICES.MAINFEED then
        local mainfeed_bid1_permit_pdb = IDXWL.is_permit_mainfeed_pdb(self.uve.idx_id)
        self.mainfeed_bid1_permit_pdb = mainfeed_bid1_permit_pdb or false -- 默认值保护
    end

    -- 根据权重对bidding_weight降序排序
    local temp_list = {}
    for k, v in pairs(self.uve.strategy.bidding_weight) do
        table.insert(temp_list, {ctype = k, cwt = v})
    end
    table.sort(temp_list, function(a, b)
        return a.cwt < b.cwt
    end)
    self.sortted_strategy_bidding_weight = temp_list

    -- 特殊广告位指定竞价权重
    self:assign_imp_bidding_weight()
    --ngx.log(ngx.DEBUG, string.format("imp bidding weight dict: %s", IUtils.json_encode(self.imp_bidding_weight_dict)))

    -- 下发特殊广告位竞价权重
    for _, imp in ipairs(self.uve.imp) do
        if self.imp_bidding_weight_dict[tostring(imp.position)] ~= nil then
            imp.bidding_weight = self.imp_bidding_weight_dict[tostring(imp.position)]
        end
    end
    self.uve.strategy["enable_bidding_weight"]= true
end

-- 获取单次请求的竞价广告位首位
-- 备注：仅在主信息流和分组流区分竞价位首位
-- 例如某次下发的广告位为[1,3,10,15], 竞价广告位首位为3
function IDX:get_req_first_bid_pos()
    -- 主信息流和分组信息流
    local first_bid_pos = -1
    if self.uve.service == D.SERVICES.MAINFEED or
            self.uve.service == D.SERVICES.GROUPFEED then
        if self.req_has_pos_1 then
            -- 请求包含广告位1且广告位个数大于等于2, 取第二个广告位
            if #self.uve.imp > 1 then
                first_bid_pos = self.uve.imp[2].position
            end
        else
            -- 请求不包含广告位1, 则取第一个广告位
            first_bid_pos = self.uve.imp[1].position
        end
    else
        first_bid_pos = self.uve.imp[1].position
    end
    self.req_first_bid_pos = first_bid_pos
end

-- 获取单次请求的竞价广告位末位
-- 备注: 仅在主信息流区分竞价位末位
-- 例如某次下发的广告位为[1,3,10,15], 竞价广告位末位为15
function IDX:get_req_last_bid_pos()
    local last_bid_pos = -1
    if self.uve.service == D.SERVICES.MAINFEED then
        if self.req_has_pos_1 then
            -- 请求包含广告位1且广告位个数大于等于2, 取最后一个广告位
            if #self.uve.imp > 1 then
                last_bid_pos = self.uve.imp[#self.uve.imp].position
            end
        else
            -- 直接取最后一个广告位
            last_bid_pos = self.uve.imp[#self.uve.imp].position
        end
    else
        last_bid_pos = self.uve.imp[#self.uve.imp].position
    end
    self.req_last_bid_pos = last_bid_pos
end

-- 特殊广告位可出候选类型过滤
-- @param origin_bidding_weight 初始的权重列表
-- @param cand_types 允许填充的候选类别列表
-- @param is_wl 过滤模式, true代表白名单过滤, false代表黑名单过滤
-- @return 过滤后的结果
function IDX:filter_imp_cand_type(origin_bidding_weight, cand_types, is_wl)
    if is_wl == nil then
        return {}
    end
    origin_bidding_weight = origin_bidding_weight or {}
    cand_types = cand_types or {}

    -- 生成特殊广告位候选权重
    local imp_sortted_bidding_weight = {}
    for _, cnode in ipairs(origin_bidding_weight) do
        if is_wl then
            if cand_types[cnode.ctype] then
                table.insert(imp_sortted_bidding_weight, cnode)
            end
        else
            if not cand_types[cnode.ctype] then
                table.insert(imp_sortted_bidding_weight, cnode)
            end
        end
    end

    return imp_sortted_bidding_weight
end

-- 将排序后的竞价权重列表转为字典
-- @param bwt_list 竞价权重列表
-- @return table 竞价权重字典
function IDX:convert_bw_list2dict(bwt_list)
    if not bwt_list or not next(bwt_list) then
        return {}
    end
    local bwt_dict = {}
    for _, node in ipairs(bwt_list) do
        bwt_dict[node.ctype] = node.cwt
    end
    return bwt_dict
end

-- 指定特殊广告位竞价权重设置
-- 包含: 主信息流首位和竞价位末位，分组流首位及热门微博流首位
-- @return 生成成功返回true，否则返回false
function IDX:assign_imp_bidding_weight()

    -- 其他场景无特殊竞价权重要求
end

-- 检查uve策略中指定的竞价权重是否合法
-- @param bidding_weight UVE策略中指定的竞价权重配置
-- @return 配置有效返回true, 否则返回false
function IDX:check_strategy_bidding_wt()
    return true
end

-- 检查uve的请求数据是否合法
-- @return 有效返回true，否则返回false
function IDX:parse_request()
    local uve = self.uve
    uve.idx_id = uve.id
    if uve.uid == nil or uve.from == nil or uve.ad_counts==nil then
        return false
    end
    return true
end

-- 广告黑名单过滤 只展示Brand和TopFans
function IDX:apply_prefilter_black_user()
    if not utils.is_black_user(self.uve.uid) then
        return
    end
end

-- 用户过滤
function IDX:apply_prefilter()
    self:apply_prefilter_black_user()
end

-- 应用过滤规则
function IDX:apply_filter_rules()
    local service = self.uve.service
    if D.FILTER_MODULE_NAME[service] == nil then
        return
    end
    local uve = self.uve
    local res, rc = FILTER_MODULE_CLASSES[service].is_black_user(uve)
    if res then
        if next(self.products) then
            for _,product in ipairs(self.products) do
                self.stats.product[product].rc = rc
            end
        end
        self.products = {}
    end
end

-- 应用灰度策略
function IDX:apply_gray()
end

-- 大v黑名单或全局黑名单中访客标注
function IDX:apply_big_v_strategy()
    if IdxBlackList.is_default_black_or_big_v_user(self.uve.user.uid) then
        self.is_black_or_big_v_uid = true  --标记当前访客
    end
end



-- 流量控制：流量百分比、降级等
function IDX:flow_control()

end


function IDX:prerequest_handle()
    local profile = require('profile')
    -- 获取用户唯一标识
    self.user_identifier_info = profile.get_user_identifier_info(self.uid)

end

--根据流量类型采取过滤产品线等策略
function IDX:apply_flow_strategy()

end

function IDX:get_imps_with_product(product)

end

-- 根据产品线下发实验策略
-- @param product 业务规范中定义的产品线英文名称
-- @return 该产品线应下发的实验信息
function IDX:get_experiment_with_product(product)
    -- 为各产品线下发实验
end

-- 初始化试验策略
-- 备注: 没有运行实验时，返回结果中不存在description字段
-- @return true 成功，false 失败
function IDX:init_experiment()
    return true
end

-- 依据实验信息过滤请求
function IDX:experiment_filter()

end

-- 特殊广告位请求前过滤
-- 目标: 当特殊广告位不包含某产品线下任何候选类型, 则不对该产品线下发该广告位
function IDX:filter_product_imps(product, imps)

end


-- 初始化广告引擎模块
-- @return true 成功，false 失败
function IDX:init_module()
    local module_dict = {}
    for _,product in ipairs(self.strategy_products) do
        local module_class = PRODUCT_MODULE_CLASSES[product]
        local m = module_class:new()
        module_dict[product] = m
    end
    self.module_dict = module_dict

    return true
end

-- 调用各广告引擎模块，生成请求串
function IDX:generate_requests()
    -- 若某product生成request失败，则不请求该product的引擎，它也不参与竞价。
    local products = {}
    for _,product in ipairs(self.products) do
        local m = self.module_dict[product]
        local rc, request = m:generate_request()
        if rc == true then
            table.insert(products, product)
            table.insert(self.capture_requests, request)
            if self.is_debug then
                ngx.say("########## Request " .. product)
                if product == D.PRODUCTS.SMARTD then
                    ngx.say(IUtils.json_encode(request[2].args))
                else
                    ngx.say(request[2].body)
                end
            end
        end
    end
    self.products = products
end

-- 并行发起请求
function IDX:capture_multi()
    if next(self.capture_requests) == nil then
        ngx.log(ngx.ERR, "at least one subrequest should be specified")
        return false
    end
    self.responses = { ngx.location.capture_multi(self.capture_requests) }
end

-- 解析各广告引擎的返回结果
function IDX:parse_responses()
    for i,product in ipairs(self.products) do
        local m = self.module_dict[product]
        self.stats.product[product].rc = self.responses[i].status
        m:parse_response(self.responses[i])
        if self.is_debug then
            ngx.say("########## Response " .. product)
            ngx.say(self.responses[i].body)
        end

        if self.responses[i].status ~= ngx.HTTP_OK then
            ngx.log(ngx.ERR, string.format("capture %s fail: %s",
                    product, IUtils.json_encode(self.responses[i])))
        end
    end
end

-- 候选结果过滤
function IDX:response_filter()
    if not self.enable_ad_style then
        return
    end
end

-- 对候选进行广告主过滤
function IDX:candidates_filter_cust_id(candidates)
    if candidates == nil or next(candidates) == nil then
        return
    end
    for _, cand in ipairs(candidates) do
        if FM_1009.is_in_black_list(cand.cust_id) then
            cand.inter.status = D.CAND_STATUS.CUST_FILTED
        end
    end
end


-- prebid阶段获取impid对应的候选
function IDX:prebid_get_cands(impid)
    local cands = {} -- [{},...]

    for _,product in ipairs(self.products) do
        local m = self.module_dict[product]
        local candidates = m:get_candidates(impid) or {}
        for _,cand in ipairs(candidates) do
            table.insert(cands, cand)
        end
    end
    --ngx.log(ngx.DEBUG, string.format("impid %s cands %s", impid, IUtils.json_encode(cands)))

    return cands
end

-- bid阶段获取impid对应的候选
function IDX:bid_get_cands(impid)
    local cands = {} -- [{},...]

    for _,product in ipairs(self.products) do
        local m = self.module_dict[product]
        local candidates = m:get_bid_candidates(impid) or {}
        for _,cand in ipairs(candidates) do
            table.insert(cands, cand)
        end
    end
    return cands
end

-- 获取托价队列
--  托价队列：本次流量的所有候选中，竞价值小于winner竞价值的候选集合
--  若无，则什么也不返回
function IDX:get_leaves_with_winner(winner)
    local leaves = {} -- [{},...]
    for _,product in ipairs(self.products) do
        local m = self.module_dict[product]
        local product_cands = m:get_leaves_with_winner(winner) or {}
        for _,cand in ipairs(product_cands) do
            table.insert(leaves, cand)
        end
    end

    if #leaves <=1 then
        return leaves
    end

    local new_leaves = {}
    local max = 0
    local index = 0
    for i,cand in ipairs(leaves) do
        local value = cand.inter.bid_value
        if value > max then
            max = value
            index = i
        end
    end
    table.insert(new_leaves, leaves[index])

    return new_leaves
end

-- 底价过滤&动态起拍价过滤
function IDX:apply_floor_price(cand, cash_coef, product_coef, channel_coef)

    -- WAX正文页场景动态起拍价下线 http://git.intra.weibo.com/idx/idx-core/issues/35
    if self.uve.service == D.SERVICES.SINGLE_PAGE
            and cand.inter.product == D.PRODUCTS.WAX then
        return
    end

    -- 获取低价
    -- UVE下发的单位是：元/千次曝光，IDX竞价值单位：毫/一次
    local floor_prices = self.uve.strategy.floor_price or {}
    local floor_price_key = D.PRODUCT_PRICE_KEYS[cand.inter.product]
    local floor_price =  floor_prices[floor_price_key] or 0
    floor_price = floor_price * 10  -- 转换为 毫/一次
    cand.inter.floor_price = floor_price

    -- 底价过滤
    if cand.inter.bid_value <= cand.inter.floor_price then
        cand.inter.status = D.CAND_STATUS.FLOOR_PRICE_FILTED
        --ngx.log(ngx.DEBUG, "discard ", IUtils.json_encode(cand))
        return
    end

    -- 只对WAX启用动态起拍价，且只对非PDB类型广告
    if cand.inter.product ~= D.PRODUCTS.WAX then
        return
    end
    if cand.inter_ext.bid_model.is_WAX_PDB == true then
        return
    end
    -- WAX动态底价豁免
    --  http://git.intra.weibo.com/ad/adx/wax_engine/delivery/wax_delivery/wikis/wax_%E5%8A%A8%E6%80%81%E5%BA%95%E4%BB%B7%E8%B1%81%E5%85%8D
    if cand.inter_ext and cand.inter_ext.exempt_floor == true then
        return
    end
    local d = {
        cash_coef = cand.inter.cash_coef,
        product_coef = cand.inter.product_coef,
        channel_coef = cand.inter.channel_coef,
        gender_code = self.uve.user.gender_code,
        age_code = self.uve.user.age_code,
        city_code = self.uve.ext.city_code,
        os_code = SfstConf.get_os_code(self.uve.device)
    }
    local dlp_value = FM_1002.get_value(d)
    --ngx.log(ngx.DEBUG, string.format("value %d dlp_value %d args: %s cand %s", cand.inter.bid_value, dlp_value, IUtils.json_encode(d), IUtils.json_encode(cand)))

    if cand.inter.bid_value < dlp_value then
        cand.inter.status = D.CAND_STATUS.FLOOR_PRICE_FILTED
        --ngx.log(ngx.DEBUG, string.format("discard value %d dlp_value %d args: %s cand %s", cand.inter.bid_value, dlp_value, IUtils.json_encode(d), IUtils.json_encode(cand)))
        return
    end
end


-- 竞价前处理逻辑 品速融入超粉灰度版本
--1. 获取所有广告位所有候选
--2. 设置所有候选竞价权重
--3. 计算所有候选竞价值并进行底价过滤
--4. 广告主候选黑名单过滤
function IDX:prebid_handler()
    local strategy = self.uve.strategy
    -- 获取所有产品的所有候选
    local all_cands = {} -- array
    for i,impid in ipairs(self.impids) do
        local cands = self:prebid_get_cands(impid)
        for _, cand in ipairs(cands) do
            -- 设置各候选竞价权重
            local bid_wt_dict = self.imp_bidding_weight_dict[tostring(cand.position)] or strategy.bidding_weight
            cand.inter.bid_wt = bid_wt_dict[cand.cand_type] or 1 --默认权重为1, 理论上不会触发默认值设置
            table.insert(all_cands, cand)
        end
    end

    -- 计算竞价值&底价过滤
    for _,cand in ipairs(all_cands) do
        local ecpm = cand.ecpm
        local cash_coef = cand.cash_coef
        local product_coef = strategy.product[cand.inter.product]
        local channel_coef = strategy.channel[cand.channel]

        -- 竞价值计算
        local value = ecpm * cash_coef * product_coef * channel_coef  -- Note: ctr=1
        cand.inter.bid_value = value
        cand.inter.product_coef = product_coef
        cand.inter.channel_coef = channel_coef
        cand.inter.cash_coef = cash_coef

        self:apply_floor_price(cand)
    end

    -- videofeed场景，对候选进行广告主黑名单过滤
    if self.uve.service == D.SERVICES.VIDEOFEED then
        self:candidates_filter_cust_id(all_cands)
    end


end



-- 竞价
function IDX:bid()
    -- 计算所有广告位所有候选，并进行底价过滤
    self:prebid_handler()
    local BidModel = require("ad_idx.idx_bid_model")
    local winners = {}
    for i,impid in ipairs(self.impids) do
        local cands = self:bid_get_cands(impid)
        if next(cands) then
            local params = {
                service = self.uve.service,
                strategy = self.uve.strategy,
                imp = self.impids[i],
                position_index = i,
                cands = cands,
                model_version = "v3"
            }
            local model = BidModel:new(params)
            winners = model:bid()
        end
    end

    -- 尾部投放,只有存在于有未填充广告的广告位时
    self:tail_push(winners)

    self.winners = winners
    --ngx.log(ngx.DEBUG, "wins ", IUtils.json_encode(self.winners))
end

-- 删除有广告胜出的广告位
function IDX:delete_impid(impid)
    for i, v in ipairs(self.miss_impids) do
        if v.impid == impid then
            table.remove(self.miss_impids, i)
        end
    end
end

-- 尾部投放，在存在有未填充广告的广告位时，将SmartD的未曝光候选填入
function IDX:tail_push(winners)

end

-- 在相应的产品模块中，添加在尾部投放中填充的候选
function IDX:push_tail_wins(cand)
    local product = cand.inter.product
    if D.TAIL_PUSH_MODULES[product] then
        local m = self.module_dict[product]
        if m then
            if m["reset_mark"] then
                m:reset_mark(cand)
            end
            m:push_wins(cand)
        end
    end
end

-- 竞价后置逻辑
function IDX:postbid()
    if not next(self.winners) then
        return
    end
end

function IDX:generate_response_part_ext()
    local ext = {}
    local timestamp_us = {}
    timestamp_us["start"] = string.format("%d", self.stats.stime)
    timestamp_us["end"] = string.format("%d", self.stats.etime)
    ext["timestamp_us"] = timestamp_us
    if self.uve.ext ~= nil then
        ext["uve_timestamp"] = self.uve.ext.uve_timestamp or 0
    end
    return ext
end

-- 生成response，并回复客户端
function IDX:response_uve()
    local resp_data = {}
    resp_data.id = self.uve.id or ""

    -- 以position升序排列竞价胜出的广告
    table.sort(self.winners, function (a, b)
        return a.position < b.position
    end)

    resp_data["data"] = {}
    for _,winner in ipairs(self.winners) do
        local resp_data_ = {}

        resp_data_["service"] = winner["service"]

        resp_data_["position"] = winner["position"]
        resp_data_["id"] = winner["id"]
        resp_data_["bid_price"] = winner["bid_price"]
        resp_data_["ad_type"] = winner["ad_type"]
        resp_data_["product"] = winner["product"]
        resp_data_["recommend"] = winner["recommend"]
        table.insert(resp_data["data"],resp_data_)
    end
    local cjson = require('cjson')
    ngx.say(cjson.encode(resp_data))
end

-- 获取尾部投放的引擎未胜出的广告候选
function IDX:get_leaves_candidates()

end

-- 返回记录频次日志的请求
-- 频次日志需要记录到RIN

-- @return table 所有的频次请求
function IDX:record_freqlog()
end


-- 记录各产品线曝光信息
function IDX:record_explog()

end

-- 记录竞价跟踪日志(本地)
-- 新增experiment字段
function IDX:record_trace_log()

end

-- 收官 [>\/<]
--  1. 记录一切需要记录到本地的、网络的数据
--  2. 请求那些在结束时，需要访问网络的request，
--     这里只发起请求，不会处理响应，也不关心成功失败
--  3. 这里均用 self.strategy_products 来遍历module
--     有些业务不获取广告数据，但需IDX记录某些信息，如
--     AddFans的移动端不感兴趣，不候补广告，但需记录不感兴趣
function IDX:finalize_handler()
    -- 先返回数据给UVE，后做其他处理
    -- NOTE: 返回给UVE的耗时没有包含写频次，记录曝光日志的时间
    self:response_uve()

    -- 记录各产品线曝光日志
    self:record_explog()
end

-- 请求处理主流程
-- param req_body为uve请求体body字符串
-- param uve 解析后的uve请求体结构
function IDX:run(req_body, uve)
    -- NOTE: 不可改变以下函数的调用顺序

    -- 初始化
    self:init(req_body, uve)

    -- 解析UVE请求
    if self:parse_request() == false then
        self:response_uve()
        return
    end

    -- 前置过滤
    self:apply_prefilter()

    -- IDX灰度策略
    self:apply_gray()

    -- 应用业务策略
    self:apply_strategy()

    -- 应用黑名单过滤
    self:apply_filter_rules()

    -- 应用流量控制
    self:flow_control()

    -- 请求前过滤
    self:prerequest_filter()

    -- 应用流量策略
    self:apply_flow_strategy()

    -- 请求画像及依赖资源
    self:prerequest_handle()

    --初始化试验策略
    self:init_experiment()

    -- 依据实验过滤流量
    self:experiment_filter()

    -- 初始化广告引擎模块
    self:init_module()

    -- 生成请求串
    self:generate_requests()

    -- 并行请求广告引擎
    self:capture_multi()

    -- 解析响应
    self:parse_responses()

    -- 过滤
    self:response_filter()

    -- 竞价
    self:bid()

    -- 竞价后置逻辑
    self:postbid()

    -- 收官[>\/<]
    self:finalize_handler()
end

return IDX

